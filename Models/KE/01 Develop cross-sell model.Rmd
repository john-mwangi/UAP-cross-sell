---
title: "Develop cross-sell model"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(recommenderlab)
library(tidyverse)
```

# IMPORT RATING MATRIX

```{r}
products_rating_matrix <- readRDS("../../Data Prep/KE/products_rating_matrix.rds")

dim(products_rating_matrix)
```
## Product holding summary

Customers hold an average of 1 insurance product.

```{r}
summary(rowCounts(products_rating_matrix))
```
## Product holding distribution

A little over 1K customers hold more than 2 products. Cross-validated training will therefore not be supported. A good number to support CV training is \~10 products per customer.

```{r}
as(products_rating_matrix, "data.frame") %>% 
  count(user, name = "product_holding") %>% 
  arrange(desc(product_holding)) %>% 
  ggplot(aes(x = product_holding))+
  geom_histogram(binwidth = 1)+
  geom_vline(xintercept = 3, linetype = "longdash")+
  stat_bin(binwidth=1, geom="text", aes(label=..count..), vjust=0.25)+
  scale_y_log10()+
  scale_x_continuous(breaks = seq(1,6,1),
                     labels = seq(1,6,1))+
  labs(title = "Customer Product Holding",
       subtitle = "A little over 1K customers hold more than 2 products")
```

## Distribution of customers

Those holding more than 2 products

```{r}
users_multple_products <-
as(products_rating_matrix,"data.frame") %>% 
  count(user) %>% 
  arrange(desc(n)) %>% 
  filter(n>2) %>% 
  pull(user)
```

94% of products being held multiple times are in Asset Management.

```{r}
as(products_rating_matrix, "data.frame") %>% 
  filter(user %in% users_multple_products) %>% 
  count(item) %>% 
  arrange(desc(n)) %>% 
  mutate(prop = n/sum(n),
         sum_prop = cumsum(prop))
```

# VALIDATION

## Evaluation scheme

Train-test split.

```{r}
es <- 
evaluationScheme(data = products_rating_matrix, 
                 method = "split",
                 train = 0.7,
                 k = 1,
                 given = 1)
```

## List of recommenders

```{r}
recommenderRegistry$get_entry_names()
```

AR removed as it does not provide meaninful results despite reducing confidence to 0.0

```{r}
algorithms <- list(
  popular = list(name = "POPULAR", param = NULL),
  ibcf = list(name = "IBCF", param = NULL),
  ubcf = list(name = "UBCF", param = NULL),
  random = list(name = "RANDOM", param = NULL),
  rerecommend = list(name = "RERECOMMEND", param = NULL))
  #ar = list(name = "AR", param = list(confidence = 0.0)))
```

## Obtain evaluation results

```{r}
gc()

ev_list <- 
evaluate(x = es,
         method = algorithms,
         type = "topNList",
         n = seq(1,10,1))
         #n = c(1,3,5,10))

gc()
```

# EVALUATION METRICS

## Definition

Reference: [Precision-Recall formula](https://en.wikipedia.org/wiki/Precision_and_recall) in the Information Retrieval context.

Precision: Out of all the recommendations returned by the tool, how many of those were relevant? Having a high number here means that many of the products recommended were relevant to the customer. This can be viewed as a measure of false-positives.

Recall: Out of all the recommendations returned by the tool, were all relevant recommendation in that list or some were missing? Having a high number here means that at least one of those products being recommended was relevant.

## PR Curves

```{r}
names(ev_list)
```

```{r}
plot(x = ev_list, y = "prec/rec", annotate=TRUE, legend="topleft")
```

## Illustration

What the results below mean is that if we were to recommend 10 products to the user, there is a high chance that at least one of them will be relevant. 

On the other hand, if we were to recommend only 1 product to the user there is a slightly better chance that this one item is the most relevant one - though the hard numbers are not impressive.

```{r}
pop_eval <- avg(ev_list$popular) %>% 
  as_tibble()

ibcf_eval <- avg(ev_list$ibcf) %>% 
  as_tibble()
  
pop_eval %>% 
  ggplot(aes(x = recall, y = precision))+
  geom_line()+
  geom_text(aes(label=n), nudge_y = 0.0035)+
  labs(title = "PR Curve - Popular Recommender")
  
ibcf_eval %>% 
  ggplot(aes(x = recall, y = precision))+
  geom_line()+
  geom_text(aes(label=n), nudge_y = 0.0035)+
  labs(title = "PR Curve - IBCF Recommender")
```


## AUC

```{r}
ibcf_auc <- pracma::trapz(x = ibcf_eval$recall, y = ibcf_eval$precision)
pop_auc <- pracma::trapz(x = pop_eval$recall, y = pop_eval$precision)

ibcf_auc
pop_auc
```

## Operating Point

We determine the optimal number of products to recommend (not per business line). This is the point closest to (1,1).


```{r}
pop_eval %>% 
  select(n,
         x = recall,
         y = precision) %>% 
  mutate(dist = sqrt((x-1)^2 + (y-1)^2)) %>% 
  arrange(dist)


ibcf_eval %>% 
  select(n,
         x = recall,
         y = precision) %>% 
  mutate(dist = sqrt((x-1)^2 + (y-1)^2)) %>% 
  arrange(dist)
```
From the above results:
* It is best to recommend 3 products - followed by 4 or 5 products in that order.
* For the Popular recommender, recommending a single product is better than recommending 2 products.
* For IBCF recommender, recommending 2 products is better than recommending a single product.
* Ideally, work with 3 +/- 1 product.

# HYBRID RECOMMENDER

We'll create a hybrid of the IBCF and POP models

## Define weights

```{r}
rec_weights <-
  crossing(m1 = seq(0,1,0.1),
           m2 = seq(0,1,0.1)) %>% 
  filter(m1 + m2 == 1, 
         !m1 %in% 1,
         !m2 %in% 1) %>% 
  mutate(weights = paste0(m1,",",m2)) %>% 
  pull(weights)

rec_weights
```

## Hybrid recommenders

List of hybrid recommenders with different weights

```{r}
hybrids_list <- list()

for (w in seq_along(rec_weights)){
hybrids_list[[w]] <- list(
  hybrid = list(name = "HYBRID", 
                param = list(
                  recommenders = list(
                    popular = list(name = "POPULAR", param = NULL),
                    ibcf = list(name = "IBCF", param = NULL)),
                  weights = as.numeric(strsplit(rec_weights[[w]],",")[[1]])
                                )))
  
}
```

## Obtain evaluation results

```{r}
doParallel::registerDoParallel(parallel::detectCores())

ev_hybrid <- list()
for(h in seq_along(hybrids_list)){
  ev_hybrid[[h]] <- evaluate(es, hybrids_list[[h]], n = seq(1,10,1))
}

doParallel::stopImplicitCluster()
```


## Plot all results

```{r}
for(p in seq_along(ev_hybrid)){
  plot(x = ev_hybrid[[p]], 
       y = "prec/rec", 
       annotate = TRUE,
       main = print(rec_weights[p]))
}
```


## Maximise AUC

Criteria for selecting a hybrid recommender is either:
1. One whose AUC is superior to either of the base models
2. One whose precision is superior
3. One with an operating point closest to (1,1)

Extract evaluation results.

```{r}
ev_hybrid_avg <- list()

for (h in seq_along(rec_weights)){
   ev_hybrid_avg[[h]] <- avg(ev_hybrid[[h]]) %>% 
    data.frame() %>% 
    arrange(hybrid.recall)
}

length(ev_hybrid_avg)
```

Calculate AUC for each hybrid.

```{r}
library(pracma)

hybrid_auc <- list()

for (h in seq_along(rec_weights)){
  hybrid_auc[[h]] <- trapz(x = ev_hybrid_avg[[h]]$hybrid.recall,
                           y = ev_hybrid_avg[[h]]$hybrid.precision)
}
```


## Maximise Precision

Select the hybrid with the highest precision.

```{r}
hybrid_prec <- list()

for (h in seq_along(rec_weights)){
  hybrid_prec[[h]] <- ev_hybrid_avg[[h]] %>% 
    arrange(desc(hybrid.precision)) %>% 
    head(1) %>% 
    pull(hybrid.precision)
}

hybrid_prec
```



# RESULTS COMPARISON


Compare against IBCF and POP


Put AUC results into a tibble.

```{r}
hybrids_list[[1]]$hybrid$param$recommenders[[1]]$name

hybrids_list[[1]]$hybrid$param$recommenders[[2]]$name
```
## AUC comparision

```{r}
hybrid_auc_results <- 
tibble(hybrid = paste0("hybrid_",seq(1,length(rec_weights),1)),
       auc = unlist(hybrid_auc)) %>%
  mutate(weights_pop_ibcf = rec_weights,
         base_auc = max(pop_auc,ibcf_auc)) %>% 
  arrange(desc(auc))
  

hybrid_auc_results %>% 
  filter(auc > base_auc)
```

## Precision comparison

Put precision results into a tibble.

```{r}
pop_prec <- avg(ev_list$popular) %>% 
  as_tibble() %>% 
  arrange(desc(precision)) %>% 
  head(1) %>% 
  pull(precision)


ibcf_prec <- avg(ev_list$ibcf) %>% 
  as_tibble() %>% 
  arrange(desc(precision)) %>% 
  head(1) %>% 
  pull(precision)

pop_prec
ibcf_prec
```


```{r}
hybrid_prec_results <- 
tibble(hybrid = paste0("hybrid_",seq(1,length(rec_weights),1)),
       prec = unlist(hybrid_prec)) %>%
  mutate(weights_pop_ibcf = rec_weights,
         base_prec = max(pop_prec,ibcf_prec)) %>% 
  arrange(desc(prec))
  

hybrid_prec_results %>% 
  filter(prec >= base_prec)
```


## Compile all results

```{r}
eval_results_all <-
bind_rows(
  as_tibble(avg(ev_hybrid[[7]]$hybrid)),
  as_tibble(avg(ev_hybrid[[9]]$hybrid)),
  as_tibble(avg(ev_list$popular)),
  as_tibble(avg(ev_list$ibcf))) %>% 
  mutate(model = rep(x = c("hybrid_auc","hybrid_prec","pop","ibcf"), each = 10))

dim(eval_results_all)
head(eval_results_all)
```

## Plot PR Curves

From these results, a popularity recommender seems to be most appropriate. Results will be confirmed by examining the ratings produced by it.

The AUC results are limited by the fact that the recall values never go to zero for the other recommenders apart from the hybrid recommender, giving the illusion that the hybrid recommender has a greater AUC.

```{r}
eval_results_all %>% 
  ggplot(aes(x = recall, y = precision, color = model))+
  geom_line()+
  labs(title = "PR Curves
       ")
```


# TRAINING ACTUAL MODEL

`hybrid_prec` is 90% popularity recommender hence no need to train it.

```{r}
hybrid_model_weights <- as.numeric(strsplit(x = hybrid_auc_results$weights_pop_ibcf[1], split = ",")[[1]])

hybrid_model_weights
```


```{r}
ke_ibcf = Recommender(data = products_rating_matrix, method = "IBCF")
ke_pop = Recommender(data = products_rating_matrix, method = "POPULAR")

ke_hyb = HybridRecommender(ke_pop, ke_ibcf, 
                           weights = hybrid_model_weights)
```

# USER RATINGS

User ratings represent how likely a user is to purchase a product.

```{r}
doParallel::registerDoParallel(parallel::detectCores())

gc()
pop_recommendations <- 
  predict(object = ke_pop, newdata = products_rating_matrix, type = "ratings")

gc()
ibcf_recommendations <- 
  predict(object = ke_ibcf, newdata = products_rating_matrix, type = "ratings")

gc()

hyb_recommendations <- 
  predict(object = ke_hyb, newdata = products_rating_matrix, type = "ratings")

gc()

doParallel::stopImplicitCluster()
```
## ibcf recommender

```{r}
ibcf_recommendations_df <- as(ibcf_recommendations, "data.frame")

ibcf_recommendations_df %>% 
  arrange(desc(rating))
```

## Popular recommender

We will deploy the popularity recommender because:
1. It's precision is the highest.
2. It produces stronger ratings for a marginally smaller AUC compared to IBCF.

```{r}
pop_recommendations_df <- as(pop_recommendations, "data.frame")

recommendations_df <- pop_recommendations_df %>%
  rename(ACCOUNT_NO = user,
         PRODUCT = item)
```

## Hybrid recommender


```{r}
as(hyb_recommendations,"data.frame")
```


# PRODUCT BUSINESS LINES

## Product names

```{r}
# Health products
health_products <-
readRDS("../../Data Prep/KE/health_product_holding_final.rds") %>% 
  distinct(Product) %>% 
  pull(Product)

# Asset Mgt products
asset_mgt_products <-
readRDS("../../Data Prep/KE/asset_product_holding_final.rds") %>% 
  distinct(FUND_NAME) %>% 
  pull(FUND_NAME)
```

## Create dataframe

```{r}
product_businesslines <-
tibble(PRODUCT = health_products,
       BUSINESS_LINE = "Health") %>% 
  bind_rows(
    tibble(PRODUCT = asset_mgt_products,
           BUSINESS_LINE = "Asset Management")
  )

head(product_businesslines)
```

## Join to recommendations list

```{r}
recommendations_df
recommendations_df %>%
  left_join(product_businesslines, by = "PRODUCT") %>% 
  relocate(BUSINESS_LINE, .after = PRODUCT)

head(recommendations_df)
```

## Add Grouping & Max Rating [FINAL]

Add max rating at customer level only.
Group results by customer and business line

```{r}
recommendations_df <-
recommendations_df %>% 
  group_by(ACCOUNT_NO) %>% 
  mutate(max_rating = max(rating)) %>% 
  ungroup() %>% 
  group_by(ACCOUNT_NO, BUSINESS_LINE)

head(recommendations_df)
```

## Save as data.table

This format removes the groups.

```{r}
#recommendations_df <- data.table(recommendations_df)
```


# PREDICTIONS

## Scenario 1

Where you have a customer account number and want to 3 products per business line.

```{r}
#sample_cust_num <- sample(recommendations_df$ACCOUNT_NO, 2)

sample_cust_num <- paste0(rownames(products_rating_matrix)[1:2], collapse = ",")
records <- strsplit(x = sample_cust_num, split = ",")[[1]]

recommendations_df %>% 
  filter(ACCOUNT_NO %in% records) %>%
  arrange(desc(rating)) %>% 
  slice(1:3) %>% 
  arrange(desc(max_rating))
```

## Scenario 2

You want to sort all customers across the group according to who's most likely to make a purchase and return 3 recommendations per business line.

Due to performance challenges, only the top 500 records will be displayed while remaining dataset can be availed as a link for downloading.

We allow the end-user get the top n recommended customers based on this criteria:
* Rank e.g. 1-10
* Intermediated - Yes/No
* Ownership - business line that owns the customer
* Product value - a range

Create a random sample of intermediated and unintermediated customers.

### Non intermediated customers

```{r}
recommendations_detailed %>% 
  ungroup() %>% 
  count(intermediated, ownership)
```

```{r}
non_intermediated_customers <-
recommendations_detailed %>% 
  filter(intermediated=="No")
```

### Customer sample

```{r}

recommendations_detailed_sample <-
recommendations_detailed %>% 
  arrange(desc(max_rating)) %>% 
  head(500) %>% 
  bind_rows(non_intermediated_customers)

recommendations_detailed_sample
```


```{r}
recommendations_detailed_sample %>%
  arrange(desc(max_rating),
          desc(rating),
          .by_group = TRUE) %>% 
  slice(1:3) %>% 
  filter(intermediated=="No") %>% 
  filter(ownership=="Health") %>% 
  filter(product_value>=100000 & product_value<=200000)
```


```{r}
# Full records as a spreadsheet file
recommendations_df %>% 
  arrange(desc(max_rating), 
          desc(rating), 
          .by_group = TRUE) %>%
  #slice(1:3) %>% 
  write_csv(file = "./recommendations_df.csv")

```


## Scenario 3

Include additional products on top of what one has purchased and return 3 recommendations per business line.


Capture user selections.

```{r}
user_choices <-
product_businesslines %>% 
  group_by(BUSINESS_LINE) %>% 
  slice_sample(n = 2) %>% 
  pull(PRODUCT)

#user_choices <- c("CORPORATE")
```

Identify missing product names

```{r}
not_user_choices <- colnames(products_rating_matrix)[!colnames(products_rating_matrix) %in% user_choices]

length(not_user_choices)
```

Convert to dataframe.

```{r}
choices <- tibble(choice = 
rep(x = c(1,0), 
    times = c(length(user_choices), 
              length(not_user_choices))
    ))

user_choices_df <-
choices %>% 
  mutate(user_choices = c(user_choices, not_user_choices))

head(user_choices_df)
```


```{r}
user_choices_df <- 
pivot_wider(data = user_choices_df,
            names_from = user_choices, 
            values_from = choice)

head(user_choices_df)
```

Convert to binary rating matrix.

```{r}
user_choices_mat <- as.matrix(user_choices_df)

colnames(user_choices_mat)[1:10]

user_choices_ratmat <- as(user_choices_mat,"binaryRatingMatrix")

class(user_choices_ratmat)
```

Recommend products.

```{r}
user_choice_recommendations <- 
  predict(object = ke_pop, 
          newdata = user_choices_ratmat, 
          type="ratings")
```


```{r}
as(user_choice_recommendations, "data.frame") %>% 
  rename(PRODUCT = item) %>%
  left_join(product_businesslines, by = "PRODUCT") %>% 
  relocate(BUSINESS_LINE, .after = PRODUCT) %>% 
  group_by(BUSINESS_LINE) %>% 
  arrange(desc(rating), .by_group = TRUE) %>% 
  slice(1:3)
```

## Scenario 4

A table of the most popular products.

Comment: If you examine Account Number vs Products for Health vs Asset Mgt, Asset Mgt has 54K records, while Health Insurance has 18K records.


Get product name and sell date.

```{r}
popular_products <-
as(products_rating_matrix, "data.frame") %>% 
  rename(PRODUCT = item) %>% 
  count(PRODUCT) %>% 
  left_join(product_businesslines, by = "PRODUCT") %>% 
  relocate(BUSINESS_LINE, .after = PRODUCT) %>%
  group_by(BUSINESS_LINE) %>% 
  arrange(desc(n), .by_group = TRUE)

popular_products
```


## Scenario 5

Valid product names.

```{r}
tibble(colnames(products_rating_matrix)) %>% write_csv("./valid_product_names.csv")
```


```{r}
acc_nums_upload <- 
  readxl::read_excel(path = "./cs_upload_template.xlsx",
                     sheet = "customer_acc") %>% 
  distinct(ACCOUNT_NO) %>% 
  pull(ACCOUNT_NO)

cust_prods_upload <- 
  readxl::read_excel(path = "./cs_upload_template.xlsx", 
                     sheet = "customer_prod") %>% 
  distinct(PRODUCT) %>% 
  pull(PRODUCT)
```

### Customer numbers

Recommendations for customer numbers provided.

```{r}
recommendations_df %>% 
  filter(ACCOUNT_NO %in% acc_nums_upload) %>% 
  slice(1:3) %>% 
  arrange(desc(max_rating),
          desc(rating), 
          .by_group = TRUE)
```

### Customer products

Recommendations on product list provided.

Capture user selections.

```{r}
user_choices <- cust_prods_upload
```

Identify missing product names

```{r}
not_user_choices <- colnames(products_rating_matrix)[!colnames(products_rating_matrix) %in% user_choices]

length(not_user_choices)
```

Convert to dataframe.

```{r}
choices <- tibble(choice = 
rep(x = c(1,0), 
    times = c(length(user_choices), 
              length(not_user_choices))
    ))

user_choices_df <-
choices %>% 
  mutate(user_choices = c(user_choices, not_user_choices))

head(user_choices_df)
```


```{r}
user_choices_df <- 
pivot_wider(data = user_choices_df,
            names_from = user_choices, 
            values_from = choice)

head(user_choices_df)
```

Convert to binary rating matrix.

```{r}
user_choices_mat <- as.matrix(user_choices_df)

colnames(user_choices_mat)[1:10]

user_choices_ratmat <- as(user_choices_mat,"binaryRatingMatrix")

class(user_choices_ratmat)
```

Recommend products.

```{r}
user_choice_recommendations <- 
  predict(object = ke_pop, 
          newdata = user_choices_ratmat, 
          type="ratings")
```


```{r}
as(user_choice_recommendations, "data.frame") %>% 
  rename(PRODUCT = item) %>%
  left_join(product_businesslines, by = "PRODUCT") %>% 
  relocate(BUSINESS_LINE, .after = PRODUCT) %>% 
  group_by(BUSINESS_LINE) %>% 
  arrange(desc(rating), .by_group = TRUE) %>% 
  slice(1:3)
```


# LIMITATIONS

1. Product holding is per customer is 1 implying there is no cross-selling happening. This makes it harder to identify cross-selling trends.
2. Assumption: 1 account number, 1 customer.

# EXPORT

```{r}
# Models
saveRDS(object = ke_ibcf, file = "./ke_ibcf.rds")
saveRDS(object = ke_pop, file = "./ke_pop.rds")
saveRDS(object = ke_hyb, file = "./ke_hyb.rds")

# User ratings
saveRDS(object = pop_recommendations_df, 
        file = "./pop_recommendations_df.rds")

saveRDS(object = ibcf_recommendations_df, 
        file = "./ibcf_recommendations_df.rds")

saveRDS(object = recommendations_df,
        file = "./recommendations_df.rds")

# Popular products
saveRDS(object = popular_products, file = "./popular_products.rds")

# Product business lines
saveRDS(object = product_businesslines, file = "./product_businesslines.rds")

# Sample of customers to display
saveRDS(object = recommendations_detailed_sample, 
        file = "./recommendations_detailed_sample.rds")

# Project image
save.image(file = "./15Apr_Models.RData")

# Image containing trained model
load("./07Apr_Models.RData")

getwd()
```



