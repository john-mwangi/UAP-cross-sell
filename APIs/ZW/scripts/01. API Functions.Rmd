---
title: "ZW APIs"
author: "John Mwangi"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# ABOUT

This is the main file for creating, documenting, and testing the development process of the APIs.

# Packages

```{r message=FALSE, warning=FALSE}
rm(list = ls())

library(httr)
library(jsonlite)
library(recommenderlab)
library(DBI)
library(RSQLite)
library(tidyverse)
```

# Required objects

```{r}
zw_rec_model <- readRDS(file = "../../App/uap_cross_sell/objects/models/Zimbabwe.rds")
zw_products_rating_matrix <- readRDS(file = "../../App/uap_cross_sell/objects/rating_matrix/Zimbabwe.rds")
```

# Database connections

```{r}
zw_sqlite_path <- "../../App/uap_cross_sell/db/zw_cs.db"
con_zw <- dbConnect(drv = SQLite(), zw_sqlite_path)
```


# Scenario 1

Where the Account Number is provided, the model returns:
* Product recommendations for the customer
* Ratings for the various products

Returns:
* dataframe converted to json

Additional information (same columns that are on the tool):
* All the account numbers tied to the customer owning that account number
* Business line of the product
* Max rating among the products
* Customer ownership
* Whether the customer is intermediated or not
* Product value of the recommended product
* Additional customer details: product holding, products held, account numbers per business line

## Create a function

```{r}
predict_on_accounts <- function(account_num, recomm_limit){
  
table_order <- c("UNIQUE_ID", "PRODUCT", "BUSINESS_LINE", "rating", "max_rating", "ownership", "intermediated", "product_value", "customer_details")
  
# Clean & vectorize input values
input_account_num <- str_remove_all(string = account_num, 
                                    pattern = " ")
input_account_num <- str_split(string = input_account_num, 
                               pattern = ",")[[1]]

# Retrieve unique identifiers
res_tbl <- tibble()
  
for(account in seq_along(input_account_num)){
  
  query_stmt <-
  paste0("SELECT * FROM uniqueid_accounts WHERE ACCOUNT_NO LIKE '%",input_account_num[account],"%'") %>% 
  SQL()
  
  query_result <- 
  dbSendStatement(conn = con_zw, 
                  statement = query_stmt)
  
  res_tbl <- rbind(res_tbl, dbFetch(res = query_result))
  dbClearResult(res = query_result)
}

cust_unique_ids <- res_tbl %>% pull(UNIQUE_ID)

# Predict & merge
user_account_recommendations <-
predict(object = zw_rec_model, 
        newdata = zw_products_rating_matrix[cust_unique_ids,], 
        type = "ratings") %>% 
  as("data.frame") %>% 
  rename(UNIQUE_ID = user, PRODUCT = item) %>% 
  left_join(tbl(src = con_zw, "product_businesslines"), 
            by = "PRODUCT", 
            copy = TRUE) %>% 
  left_join(tbl(src = con_zw, "uniqueid_accounts"), 
            by = "UNIQUE_ID", 
            copy = TRUE) %>% 
  left_join(tbl(src = con_zw, "product_values"), 
            by = "PRODUCT", 
            copy = TRUE) %>% 
  left_join(tbl(src = con_zw, "customer_details_final"), 
            by = "UNIQUE_ID", 
            copy = TRUE) %>% 
  select(any_of(c("ACCOUNT_NO",table_order))) %>% 
  select(-UNIQUE_ID) %>% 
  group_by(ACCOUNT_NO, BUSINESS_LINE) %>% 
  mutate(max_rating = max(rating)) %>% 
  relocate(max_rating, .after = rating) %>% 
  arrange(desc(rating)) %>% 
  slice(1:recomm_limit)

return(user_account_recommendations)
}
```

## Test the function

```{r}
predict_on_accounts(account_num = "1101981741,107793,41413165", recomm_limit = 3)
```

## Create API

Refer to `plumber.R` When run, this will return a json file.

## Test API results

View json file in tabular format.

```{r}
fromJSON(txt = "../outputs/response_scenario1.json")
```

## Run API

Refer to `run-plumber.R` This will prevent the API's port from changing and allow it to be ran as a background job.

Run `run-plumber.R` as a job.

## Call the API

Send a http call to the API. The request to this call should have status 200.

```{r}
base_url <- "http://127.0.0.1:6208/predict-on-accounts"

params <- list(account_num = "1101981741,107793,41413165", recomm_limit = 3)

query_url <- modify_url(url = base_url, query = params)

request <- GET(url = query_url)

response <- content(x = request, as = "text", encoding = "utf-8")

fromJSON(txt = response)
```

Convert call to a function.

```{r}
api_call_1 <- function(account_num, recomm_limit){
  
  base_url <- "http://127.0.0.1:6208/predict-on-accounts"
  
  params <- list(account_num = account_num, recomm_limit = recomm_limit)
  
  query_url <- modify_url(url = base_url, query = params)
  
  request <- GET(url = query_url)
  
  response <- content(x = request, as = "text", encoding = "utf-8")
  
  fromJSON(txt = response)
}
```


```{r}
api_call_1(account_num = "1101981741,107793,41413165", recomm_limit = 3)
```

# Scenario 2

The function returns a list of prospective customers based on selected user criteria.


```{r}
retrieve_top_customers <- function(ownership, intermediated, min_value, max_value, recomm_limit){
  
top_customers <-
tbl(src = con_zw, "recommendations_detailed") %>%
  group_by(ACCOUNT_NO, BUSINESS_LINE) %>% 
  filter(intermediated == !!intermediated) %>% 
  filter(ownership == !!ownership) %>% 
  filter(product_value >= min_value) %>% 
  filter(product_value <= max_value) %>% 
  collect() %>% 
  slice(1:recomm_limit)

return(top_customers)
}
```

Test function.

```{r}
retrieve_top_customers(ownership = "Lending", 
                       intermediated = "No", 
                       min_value = 0000, 
                       max_value = 200000, 
                       recomm_limit = 3)
```

# Scenario 3

The function returns additional products on top of the products that a user has already selected.

```{r}
predict_on_choices <- function(user_choices, recomm_limit){
    
  #Convert to a table
  choices <- 
    tibble(choice = rep(x = c(1,0), 
                        times = c(length(user_choices), 
                                  length(not_user_choices))
    ))
  
  user_choices_df <-
    choices %>% 
    mutate(user_choices = c(user_choices, not_user_choices)) %>% 
    distinct(user_choices, .keep_all = TRUE)
  
  #Convert to wide format
  user_choices_df <- 
    pivot_wider(data = user_choices_df,
                names_from = user_choices, 
                values_from = choice)
  
  #Convert to binaryRatingMatrix
  user_choices_mat <- as.matrix(user_choices_df)
  user_choices_ratmat <- as(user_choices_mat,"binaryRatingMatrix")
  
  #Predict using model
  user_choice_recommendations <-
    tryCatch(expr = predict(object = zw_rec_model, 
                    newdata = user_choices_ratmat, 
                    type="ratings"),
             error = function(e){
               stop("Ensure the products specified match the selected country.")
             })
  
  #Convert prediction to dataframe
  user_choice_recommendations_df <-
    as(user_choice_recommendations, "data.frame") %>% 
    rename(PRODUCT = item) %>%
    left_join(tbl(src = con_zw, "product_businesslines", 
                  copy = TRUE),
              by = "PRODUCT") %>% 
    left_join(tbl(src = con_zw, "product_values"), 
              copy = TRUE,
              by = "PRODUCT") %>% 
    relocate(BUSINESS_LINE, .after = PRODUCT) %>% 
    group_by(BUSINESS_LINE) %>% 
    arrange(desc(rating), .by_group = TRUE) %>% 
    slice(1:recomm_limit) %>% 
    select(-accounts)
  
  return(user_choice_recommendations_df)
  }
```


